# Portable-FFB-wheel  
# ポータブルFFB(フォースフィードバック)ハンドルコントローラー  
  
![システム全体](https://github.com/user-attachments/assets/cdb29a52-c8bf-4e08-be66-35ae8979e4c9)

可搬型のFFBホイール2作目です。前作はこちら↓  
https://github.com/Toshi2020/Handheld-FFB-wheel  
  
**●前作からの変更点**  
*①ブラシレスモーターの採用によるダイレクトドライブ*  
→前作ではブラシ付きDCモーターとギアによる減速機構を使用していたため、ギアのバックラッシュにより反力の正負の切り替わり時に空白(遊び)が生じていました。またステア操作時のギアのゴリゴリ感をどうしても消せませんでした。今回ブラシレスモーターによるダイレクトドライブとすることで滑らかな反力を得ることができました。  
→なおモーターは低回転高トルクのジンバル用のブラシレスモーターを使いました。  
  
*②ロータリーエンコーダーの採用*  
→前作ではステア舵角の検出のためにボリューム(VR:可変抵抗器)を使用していました。そのためステアの回転範囲は270°しかありませんでしたが、今回磁気式のエンコーダーの採用により無限に回せるようになりました。(といってもソフトウェアでは実車同等の900°としてあります)  
→また前作ではマイコンのA/D分解能が10bit(0～1023)とステアの微小舵角の検知には不足だったので、フィルタを通すことで見かけ上の分解能を上げていました。そのため車両の直進安定性がいまいちでした。今回のエンコーダーの分解能が12bit(0～4095)/回転と十分な分解能が得られるため角度はフィルタなしでそのまま使用しています。これによりステアの応答性と車両の直進安定性が向上しました。  
  
*③ワイヤレスペダルの採用*  
→前作ではアクセルとブレーキをジョイスティックにより手入力していたので、車を運転している感じが乏しいのが不満でした。今回アクセル＆ブレーキそれぞれバッテリーで作動する足踏み式のユニットとしてコントローラー本体とはワイヤレス接続としました。これにより操作感が向上しただけでなく、好みの場所にペダルをレイアウトできるのでブレーキを左右どちらの足でも踏むことができますし、使わないときには簡単に脇へ片づけておくことができるようになりました。  
→なおコントローラー本体とPCの間はUSBによる有線接続です。モーターを駆動するための電力を供給する必要がありますので。  
  
*④ESP32-S2の採用*  
→前作ではマイコンとしてArduino Pro Micro(Leonardo)を使っていましたが、今回はESP32-S2を使いました。ESPマイコンの持つESP-NOWの機能によりペダルのデータを受信しています。  
![システム構成color](https://github.com/user-attachments/assets/e41290e1-f128-4253-87b1-27bf82d3b43d)

  
**●動作状況の動画はこちら。**  
https://youtu.be/h3qvR7cWo4A
  
**●各ゲームごとの設定などはこちら↓のブログに記述しました。**  
https://minkara.carview.co.jp/userid/3336538/blog/48443198/
  
**●主な部品(価格は2024年末時点)**  
*★コントローラー本体*  
①ジンバルモーター: 2804 100KV AliExpress購入価格 1,262円  
②マイコンボード: ESP32-S2 AliExpress購入価格 464円  
③磁気式エンコーダー: AS5600 Amazon購入価格 単価344円  
④PchMOSFET: TJ8S06M3L 秋月購入価格 単価60円x3 = 180円  
⑤N型MOSFET: TK8S06K3L 秋月購入価格 単価60円x3 = 180円  
⑥H-CMOS: 74HC14 秋月参考価格 30円  
⑦タクトスイッチ:秋月購入価格 単価30円x4 = 120円  
⑧ショットキーダイオード: 1S4 秋月参考価格 単価14円  
⑨分割ロングピンソケット: 秋月参考価格 80円  
その他パーツは手持ちの物ですがそれを加味してもコントローラー本体で2,800円ほどかと。
  
*★ペダルユニット*  
①エクスプレッションペダル: M-Audio Amazon購入価格 単価2,445円x2 = 4,890円  
②マイコンボード: ESP-01S AliExpress購入価格 単価188円x2 = 376円  
③三端子レギュレータ3.3V: NJU7223DL1 秋月購入価格 単価45円x2 = 90円  
④18650チャージャーボード＆ソケット: Amazon購入価格 単価80円x2 = 160円  
⑤圧縮コイルばね: 線径0.8x外径10x長さ35mm Amazon購入価格 単価82円x2 = 164円  
⑥圧縮コイルばね: 線径1.2x外径12x長さ50mm Amazon購入価格 単価95円x2 = 190円  
その他パーツは手持ちの物ですがそれを加味してもペダルユニットは2台分で6,000円ほどかと。  
しっかりとしたペダル機構を自分で1から作るのは大変そうだったので市販品を奮発してしまいました。  
  
システム全体での部品代は8,800円ほどかと思います。実際にはこれに3Dプリントのフィラメント代がかかりますね。またそれ以外に18650バッテリーが2本必要です。  
  
**●ハードウェア**  
*★コントローラー本体*  
![回路図FFBハンドルコントローラー](https://github.com/user-attachments/assets/acfa3897-1543-487f-9759-1f2f45eb5512)

  ![コントローラー平面](https://github.com/user-attachments/assets/698a98b4-0f1c-4d96-bbe5-bef5082342ad)

・マイコンとしては当初前作と同じArduino Pro MicroとESP-01Sをシリアル接続して動作確認までは行ったのですが、チップ内にWiFi(ESP-NOW)機能を持っているESP32を使った方が一つのボードでこなせてスマートかなと思い直してESP32-S2Miniに置き換えました。HID(ヒューマン・インターフェース・デバイス)になることができればいいのでESP32-S3でも行けるのではと思います。  
・モーターはジンバル用のブラシレスモーターを使いました。給電はUSBなので5Vでモーターには電流を最大0.3A程度は流したいことから直流抵抗が10～20Ω程度の物が欲しかったのですが、AliExpressではいまいちSPECが不明でした。いくつか調達して結果2804 100KVという型番の物を採用しました。巻き線抵抗は実測20Ωでした。型番の28がモーター外径、04がシャフト内径かな？、100KVが電圧当たりの回転数を表すようです。高速回転の必要はないのでKV値は小さいものがいいのではと思います。  
・モータードライバはなるべく簡単にしたかったので、秋月で比較的オン電圧が高そうなMOSFETを調達し、上側にPch下側にNchを使って両者のゲートは直結です。ゲートにシグナルジェネレータから0-5Vの波形を入れて上下が筒抜けないことを確認しました。  
![ドライバテスト波形](https://github.com/user-attachments/assets/b3916233-5ef4-43e1-9680-a3334c515516)

・ゲートドライバはH-CMOSのインバーターを5V動作で使っています。ESP32が3.3Vなのでフルスイングすれば駆動できると踏んでいます。手持ちがあったので74HC14を使いましたが74HC04でもいいかと思います。  
・モータードライバ部分への給電は、モーターを手で回した時の逆起電圧がマイコン側に回り込まないようにショットキーダイオードを入れています。  
・デバッグ用にシリアル出力とデジタル出力を取り出すためのピンを設けています。シリアルは別途USBシリアルモジュールを接続するための端子です。シリアルモジュールに通電していないときにESP32のTxDの電圧が回り込んでもダメージがないように電流制限のために1kΩの抵抗を入れています。デジタル出力はデバッグ時に1/0を出力するコードを組み込んでオシロで実行速度を観測するために使います。  
  
![メインボード](https://github.com/user-attachments/assets/2c3484db-f0cc-477f-9919-2570c2b9c017)
・SW1はD0に接続したいので、ESP32-S2に1本ピンを増設して基板上から配線を引き出しています。ESP32-S2はリセット時にD0が押されていると書き込みモードになります。ESP32-S2本体にはD0とリセットスイッチがありますが、ケースに入れた後で書き込む場合にSW1を押したままの状態でUSBに接続することで書き込みモードにします。  
・MOSFETは2段重ねにレイアウトして省スペース化しています。放熱板は無しですがほとんど発熱はしないと思います。  
  
  ![コントローラー内部](https://github.com/user-attachments/assets/212350b0-3df8-48e5-a0ba-2bf6f7288560)
・ESP32やI/Oの接続には秋月の分割ロングピンソケットを使っています。ここに差し込む側のピンに接続したリード線の根元はホットボンドで保護しています。前作のようなコネクタを使わなかったのはブレッドボードと互換とするためです。  
  
 ![モーター周り](https://github.com/user-attachments/assets/f59d9c7f-f91a-4a14-825e-5a3788b03b69)
・モーターの回転軸は中空になっているので、エンコーダー用マグネットを取り付けるためのシャフトを接着し、モーターを固定するためのブラケットをねじ止めし、最後にエンコーダーボードを取り付けてモジュール化しています。  

*★ペダルユニット*  
  ![回路図ワイヤレスペダル](https://github.com/user-attachments/assets/a28fc26a-4668-4b89-adae-cd78f142254d)

・楽器演奏用として市販されているエクスプレッションペダルを改造しました。ペダルの位置検出用のVRは端子両端で実測11kΩですがちょっと特殊で、回転可能範囲は普通のVRと同じですが0～90°でフルレンジの変化をします。これが壊れて一般的なVRに交換する時は上側の22kΩをショートすればいいと思います。ESP8266のA/Dのフルスケールは1Vなので。  
・電池動作をさせたかったので、マイコンは余計な回路が付いていないESP-01Sを使いました。ESP-01S自体のチップはESP8266ですがESP-01SにはA/Dのピンが出ていないので、チップの足から直接引き出してピンを増設しています。AWG30のラッピングワイヤを使ってルーペ下で作業しました。  
![ESP01_AD](https://github.com/user-attachments/assets/5c925070-823a-4c0a-93c8-1c552b210a2f)

・オートパワーオフを行いたかったので、VRの下側はGND直ではなくポートに接続するようにしています。オートパワーオフ中にVR側へ電流を流さないためです。  
・そのままだとA/Dの読みがノイジーだったのでVRの両端に0.1μFのコンデンサーを入れました。これで読み取りがきれいになりました。  
・電源ランプはVRに印加する電圧で点灯するようにしました。正常起動しないと電圧が出ないので、ESPの動作確認も兼ねています。  
・当初単三電池2本で動かそうかとも思ったのですが、電池交換用のリッドを設計＆加工するのが面倒かなと思い充電式としました。リチウム電池用のチャージャーと電池ケースのセットが100円もしないで入手できることがわかったので。  
・リチウムイオン電池18650を使い、チャージャーボード出力から低損失の三端子レギュレータNJU7223DL1で3.3Vを作成しています。このレギュレータ、出力側を電解コンデンサーにしないと発振して出力に高周波ノイズが乗ってしまいました。データーシートには0.1μFの電解コンとなっていますが手持ちの10μFで問題ないみたいです。  
・電源スイッチは元のペダルの底面の極性切り替えスイッチを流用しました。オートパワーオフした後で電源を入れ直した時にESP32側の電荷を素早く抜くために1kΩでディスチャージするようにしてあります。IN側を落とすとOUT側の電圧も下がることがわかったので。  
![ペダルLED](https://github.com/user-attachments/assets/c0bc60ca-eacb-4354-915a-ffc8d75fe9f7)
・チャージャーボード上のLEDをΦ2mmのアクリル丸棒で導光しました。アクリル棒の、LEDに当たる部分を少し削ってLEDチップに覆いかぶせるようにしてホットボンドで固定しています。アクリル棒を削らないと光が入っていきませんでした。  
  
![ペダル内部](https://github.com/user-attachments/assets/57140047-9834-4848-8f39-c86a8509ccbe)
・多少削る必要がありましたが丁度収まりました。それぞれホットボンドで固定しています。  
  
![ペダルバネ](https://github.com/user-attachments/assets/9ca3a8ad-cc55-4dda-b35c-d28e0b55a2d9)

・エクスプレッションペダルは音楽用なので踏んだ後で自動復帰しません。そこで戻し用にコイルバネを追加しています。今回使ったペダルの踏み板の裏側にはリブが設けられていて、コイルバネが前後にずれないので好都合でした。バネの下側のスプリングベース側のみ両面テープで固定しています。  
・当初、ブレーキペダルは実車のように踏むにしたがってぐっと重くなる(マスターシリンダーからの液圧がキャリパーに伝わってブレーキパッドがブレーキディスクを挟み込む感触を模擬する)ようにとゴムクッションを入れて実験してみました。しかし今回のようなオルガン式のペダルで爪先側を強く踏もうとすると踵側が浮いてしまい、操作に違和感があることがわかりました。そこでブレーキペダル側は強めのバネとして、踵を浮かさずに踏める点をMAXとして学習させることで妥協しました。  
  
**●ソフトウェア**  
・開発はArduino IDEで行っています。  
*★コントローラー本体*  
・ソースコードはMyAFFBWheelESP32DD以下にあります。  
・ボードタイプでESP32S2 Dev Moduleを選択してビルドします。ESP32-S2はリセット時にD0がLになっていると書き込みモードになるので、基板上のD0スイッチを押しながらリセットを押して離します。  
・書き込み後自動でリセットがかからなかったりクロックが正常に立ち上がらなかったりしてUSBの抜き差しが必要なことがありました。  
・前作では以下↓のソフトウェア群のFFB関連のコードをブラックボックスとして利用させてもらったのですが、今回もう少し踏み込んで調べました。  
>AFFBWheel  
https://github.com/vsulako/AFFBWheel
  
・HIDディスクリプタというテーブルをaddDeviceで登録するとWindows側でデバイスとして認識されます。HIDディスクリプタはデバイスの素性(自分が何のデバイスで何をPC側に送って何をPC側から受け取るか)の情報テーブルです。今回は前作同様に上記AFFBWheelのhidDescriptor.hをそのままコピーして使わせてもらってます。  
・このHIDディスクリプタを使うと16bitのアナログ軸8chとスイッチ32個のデータをPCに送ることができ、PC側からは14種類のエフェクトを受け取ることができます。  
・今回はそれらのエフェクトのうちConstantForceのmagnitudeと、PeriodicForceのoffsetの2種類だけを受け取って自前で処理しています。手持ちのいくつかのゲームで確認したところこれ以外のフォースは送られてこなかったので。よって今作はこちらにアップしたコードだけで(参考にしたオリジナルのFFB関連の処理コードをコピーせずに)ビルドできます。  
・オリジナルのAFFBWheelでは真面目に全てのエフェクトを処理しているので、今回の私のコードでうまく動かないゲームがあれば受信データを解析して処理を追加するか、AFFBWheelからFfbReportHandlerクラスとFfbEngineクラスをコピーして組み込んでもらえればいいのかなと思います。おそらくオリジナルのFfbReportHandlerはそのまま、FfbEngineはcalculateForceの引数を自前で計算したステア回転速度と加速度に変更すればいけると思います。  
・ビルドするとWindows側でコントロールパネルの「デバイスとプリンター」にESP32S2_DEVというゲームデバイスが出現します。  
・クラッチに関してはSW1を割り当てるという前提で、ボタンだけでなくアナログ軸にも出力を行うようにしています。AssettoCorsaはクラッチはアナログ軸にしか割り当てができないようなので。SW1を押した時にはスパッと切れて離すと0.2秒かけて戻るようにしています。  
・サイドブレーキはSW4を割り当てるという前提で、こちらもアナログ軸にも出力を行うようにしています。ただしクラッチとは異なりオンオフそのままMAXとMINを出力しています。  
・3相ブラシレスモーターを駆動するためにはPWMが3ch必要です。ESP32のledcAttachでPWM周波数を約39kHz(39062Hz)に設定しています。データーシートによればこの周波数なら11bit分解能が設定できるはずなのですが11bitの設定にすると出力が0のままとなってしまうので10bit(0～1024)で妥協しています。  
・逆に11bit分解能(0～2048)で使う場合の周波数の最大を値を変えながらビルドして確かめたところ19569Hzでした。ただこの周波数だと人の可聴周波数の上限に近いので私の耳では普段は音はしないのですが、モーターのうなりなのか共鳴なのかたまにキーンと聞こえることがありました。よって39kHz10bitを採用しました。  
・Arduinoとは違いESP32のPWMは1024を指示すると連続Hとなることがわかりました。  
・モーターへの正弦波指示値はあらかじめ計算して配列データとして持つことにしました。今回使用した3相のブラシレスモーターは14極のようで、位相0で通電すると1周のうち7か所で保持される角度があります。エンコーダーが1周12bit分解能(0～4095)なので、4095/7 = 585個で正弦波1周期分の配列データを用意すれば、エンコーダー1LSBに対応した指示値がダイレクトに得られます。これにより指示を配列のインデックス0～584まで(360°分)順次変化させるとモーターが1/7回転するというわけです。3つの巻き線には120°づつずらした指示を与え、回転させるときは現在のモーターの角度に対して±90°ずらした指示を与えています。  
・モーターは保持時に電流を0.3A程度流したかったのですが、今回の実測20Ωの巻き線抵抗のモーターでは、単純に正弦波データを使って駆動すると少し物足らない感じでした。そこで以下を参考に三次高調波重畳を行ったデータとしています。今回のモーターの場合コントローラ全体の消費電流はUSB簡易電流計で最大0.27A程度になりました。  
>三角波比較PWMと三次調波重畳の方法  
https://blog-firststep.com/inverter3/
  
・巻き線抵抗の小さなモーターで電流が流れすぎる場合はPWM_MAXを1024から減らす必要があります。あるいはPwmTable.hで#if 0を#if 1として三次高調波なしのテーブルを選択します。  
・PCから送られて来るフォースは据え置き型のハンコンを前提としているためでしょうが、ステアから手を放した時のフォースによる回転速度が速すぎて、ステアが行きつ戻りつを繰り返して(ハンチングして)しまいます。そのためダンパーとイナーシャによるフォースを追加しています。使用するモーターの種類によってゲイン調整が必要です。  
・PC側から受け取るフォースが0であることが1秒連続したときステアを中点付近に戻すためのスプリングフォースを追加しています。今回ステアは1回転以上できるので、初期位置が1回転以上ずれていると走り出した途端クラッシュという事態を避けるためです。ゲーム中にPCからのフォースがきっちり0で連続することはないようなのでゲーム中の外乱にはならないと思っています。  
・HIDとPCとの通信は1ms間隔で行われているようで、PCに送るSendReport処理は次の1msのタイミングまで戻ってこないことがわかりました。よってSendReport処理はすべての処理が終わった最後に入れています。  
・ということはSendReport以前の処理は1ms以内で行う必要がありますが、ESP32は充分高速なので余裕でこなせます。一番時間がかかるのはAS5600からI2Cで角度を読む処理で250μsほどかかります。I2CのクロックをAS5600の上限の1MHzにすれば180μsくらいまで短縮できますがたまに読み取りミスが起きました。たぶんプルアップ抵抗を追加すれば行けるのかもしれませんが今回は素直に400kHzで使うことにしました。所要時間はデジタル出力にパルスを出すコードを仕込んでオシロで観測しました。  
・ArduinoIDEでのloop()関数は、実際には裏でCのmain()関数内の無限ループの中から呼ばれているわけですが、ESP32-S2の場合は2秒ごとに5msのディレイが入ることがわかりました。よってsetup()の最後で自前の無限ループの中からloop()を呼んでいます。デフォルトのloop()の外側の5msの間で何をしているのかはわかりませんが、今のところ自前のループで問題なく動いているように見受けられます。  
・通電中にSW2,3,4を同時に押すとイニシャルセッティングモードとなり、ロータリーエンコーダの初期位置取得と、ペダルのMinMax取得を行うことができます。  
・SW2,3,4を同時に押している間はモーターへの指示は位相0°でフル通電するので1周7か所のどこかにステアリングセンターを合わせます。またイニシャライズしたいペダルがあれば最大ポジションまで踏んで戻すとmax/minを取得します。SWを離した瞬間に結果がEEPROMに書き込まれます。ペダルの再イニシャルが不要であれば踏む必要はありません。  
・初回の通電時にこれ↑を行うまではモーターが暴れてしまうと思います。  
・#define MOTORTESTを1にするとモーターの3相の接続チェック用ビルドとなり、アクセルペダルの踏み込みに応じてステアが右回転するようになります。ペダルの踏み込みに応じてステアの回転が滑らかに変化すれば接続はOKです。  
・デバッグ用のシリアルに関して、ESP32の場合ArduinoIDEでツール/USB CDC On BootをEnableにするとポートが現れてSerial.printが使えはするのですが、ビルド中はこのポートは消えてしまいます。いちいち再接続するのは勝手が良くないのでUSB CDC On BootはDisableとしてビルドし、USBシリアルインタフェースを別途接続できるようにしています。ビルドと同じPCに接続すればGNDは共通なので線を1本つなぐだけです。  
・私はビルド用とは別のディレクトリに置いたArduinoIDEを別インスタンスとして起動してシリアルモニタやプロッタを使っています。同じWiFi下のAndroidタブレットとPCにspacedeskを入れて起動しておくとPCがゲームで全画面表示になってもAndroid側にデバッグ画面が表示出来ていい感じです。  
  
*★ペダルユニット*  
・ソースコードはWirelessPedalTx以下にあります。  
・ArduinoIDEでボードタイプでGeneric ESP8266 Moduleを選択してビルドします。Upload Speedを3000000として以下の書き込み回路を使っています。旧ESP-01も書き込めるようプルアップ抵抗を入れています。また書き込みには不要ですが開発ボード的な使い方ができるよう信号引き出し用のコネクタを増設しています。  
![ESP01書き込み器](https://github.com/user-attachments/assets/0340c674-6951-4120-a296-90cd0d599fa8)

・コードはアクセルペダル用はCHを0に、ブレーキペダル用は1にしてビルドします。  
・ペダルユニットの処理は、A/Dを読み取り、ESP-NOWで送信し、送信を終了したらしばらく休むの繰り返しです。電池動作を前提としているので消費電流を減らすために「しばらく休む」はスリープで実現しています。  
・ESP8266のスリープモードは、Modem-Sleep、Light-Sleep、Deep-Sleepの3種類あります。Deep-Sleepはオートパワーオフ用で再起動しないと復帰しません。残るModem-SleepとLight-SleepではLight-Sleepの方が低消費ですが、内部RTCでウェイクアップさせる場合はLight-Sleepを指示してもModem-Sleepにしかならないみたいです。またデーターシートではModem-Sleepはインターバルの最短を10msから設定できるはずですが、12msを指定しないとスリープに入りませんでした。なおスリープのモードは電源電流をモニタすることで判断しています。  
・RTCではなく外部端子割り込みによってウェイクアップする設定とした場合にはLight-Sleepすることがわかりました。ただしこの場合、まずModem-Sleepになってその後Light-Sleepまで落ちる挙動になります。この時スリープ指示からModem-Sleepが開始するまでに6msほど時間がかかり、さらにLight-Sleepに落ちるまで1.6msかかりました。これでは省電力のうまみが少ないのと外部にハードウェアタイマ回路が必要なのでModem-Sleepで妥協しました。  
・インターバルが12msという事はペダルを最速1秒間に40回変化させても伝わるという事になるので、まあ良しとしました。e-sportsでは使えないのかもしれませんが。  

・ちなみにスリープしていない時の消費電流は70mA、スリープ期間中は12mA程度でした。ESP-NOWの送信パワーミニマムの場合で送信中は120mAといったところです。ESP-NOWは受信相手がいないと勝手にリトライしてくれるという事がわかりました。  
・なお電源を切り忘れてもいいように、通信が途絶えて3分経過するとオートスリープするようにしています。電源スイッチをいったんオフにしてオンにすれば復帰します。  
・コントローラ本体との通信が途絶えている期間は電源オン表示用のLEDが1秒間隔で点滅するようにしています。  
  ![ESP01電流波形](https://github.com/user-attachments/assets/a88d8ada-2de3-441e-a3a4-178f9d14b86f)

**●ESP-NOW通信プロトコル**  
![通信プロトコル](https://github.com/user-attachments/assets/5c3a3793-d128-4cf3-b11a-1c63835961d8)

・ESP-NOWは相手のMACアドレスを指定してのピアtoピアの送信か、だれもが受信できるブロードキャストでの送信が行えます。相手のMACアドレスをソースに記述するとハードウェア変更時に面倒なので、ペダルは通電後はブロードキャストで送信し、コントローラ本体からのACK受信でコントローラー本体のMACアドレスを取得し、その後ピアtoピア送信に移行するようにしました。送信データには今回のアプリ固有のIDとチャンネル番号とA/D読み取り値を入れています。アプリIDは今後他のアプリでESP-NOWを同時に使っても混信しないようにユニークな値を設定するつもりです。今回は0x88および0x89としています。  
・ESP8266とESP32ではESP-NOWの仕様に若干の違いがあります。ESP32ではピアリストに登録した相手にしか送信できませんが、ESP8266ではピアリストへの登録は不要のようです。  
・近場での通信なのでWiFiの送信パワーはミニマムに設定しています。  
  
**●3Dデータ＆組付けについて**  
・3DdataのフォルダにAutodesk Fusionのファイルと簡単なメモを入れました。  
以上です。  

